<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chat Assistant</title>
  <style>
    body {
      font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
      margin: 0;
      padding: 0;
    }

    #chat-root {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }

    .chat-toggle-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #3498db;
      color: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 1001;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .chat-toggle-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .draggable-header {
      cursor: move;
      user-select: none;
    }

    .chat-window {
      width: 450px;
      height: 500px;
      background-color: white;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      display: flex;
      overflow: hidden;
      position: fixed;
      right: 20px;
      bottom: 20px;
      z-index: 1000;
      resize: both;
      min-width: 400px;
      min-height: 400px;
    }

    .chat-window.maximized {
      width: calc(100vw - 40px);
      height: calc(100vh - 40px);
      right: 20px;
      bottom: 20px;
      resize: none;
    }

    .chat-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      background-color: #3498db;
      color: white;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      z-index: 100;
    }

    .chat-title {
      font-weight: 600;
      font-size: 14px;
    }

    .chat-controls button {
      background: none;
      border: none;
      color: white;
      font-size: 14px;
      cursor: pointer;
      margin-left: 12px;
      padding: 4px;
    }

    .chat-controls button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .sidebar {
      width: 140px;
      background-color: #2c3e50;
      color:white;
      padding: 16px 12px;
      overflow-y: auto;
      border-right: 1px solid #1a252f;
      margin-top: 48px;
      font-size: 12px;
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: #1a252f;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background-color: #3498db;
      border-radius: 3px;
    }

    .new-chat-btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      width: 100%;
      margin-bottom: 16px;
      transition: background-color 0.2s;
    }

    .new-chat-btn:hover {
      background-color: #2980b9;
    }

    .history-item {
      padding: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .history-item-content {
      flex: 1;
      overflow: hidden;
    }

    .history-item:hover,
    .history-item.active {
      background-color: #3498db;
    }

    .history-item .time {
      font-size: 10px;
      color: #bdc3c7;
      margin-top: 4px;
    }

    .delete-chat-btn {
      background: none;
      border: none;
      color: #e74c3c;
      cursor: pointer;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .history-item:hover .delete-chat-btn {
      opacity: 1;
    }

    .delete-chat-btn:hover {
      color: #c0392b;
    }

    .chat-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-top: 48px;
    }

    .new-chat-prompt {
      padding: 24px;
      text-align: center;
      color: #666;
    }

    .new-chat-prompt h3 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 14px;
    }

    .new-chat-prompt p {
      margin-bottom: 16px;
      font-size: 12px;
    }

    .messages-container {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      background-color: #f9f9f9;
    }

    .message {
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
    }

    .message.user {
      align-items: flex-end;
    }

    .message.bot {
      align-items: flex-start;
    }

    .message-bubble {
      max-width: 80%;
      padding: 10px 14px;
      word-wrap: break-word;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      font-size: 13px;
      position: relative;
    }

    .message.user .message-bubble {
      background-color: #3498db;
      color: white;
    }

    .message.bot .message-bubble {
      background-color: #e9ecef;
      color: black;
    }

    .message-time {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .message-sender {
      margin-right: 8px;
    }

    .input-area {
      display: flex;
      padding: 16px;
      border-top: 1px solid #eee;
      background-color: white;
    }

    .message-input {
      flex: 1;
      padding: 10px 14px;
      border: 1px solid #ddd;
      outline: none;
      margin-right: 12px;
      font-size: 13px;
      transition: border-color 0.2s;
    }

    .message-input:focus {
      border-color: #3498db;
    }

    .send-button {
      padding: 10px 16px;
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .send-button:hover {
      background-color: #2980b9;
    }

    .resize-handle {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 12px;
      height: 12px;
      cursor: se-resize;
      z-index: 100;
    }

    .trash-icon {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    /* ÂèçÈ¶àÂíåÂ§çÂà∂ÂäüËÉΩÊ†∑Âºè */
    .message-actions {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .action-button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 2px;
      opacity: 0;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .message.bot:hover .action-button,
    .message.bot .action-button.active {
      opacity: 1;
    }

    .icon {
      width: 14px;
      height: 14px;
      transition: fill 0.2s;
    }

    .like-icon {
      fill: #666;
    }

    .like-icon.liked {
      fill: #e74c3c;
    }

    .dislike-icon {
      fill: #666;
    }

    .dislike-icon.disliked {
      fill: #3498db;
    }

    .copy-icon {
      fill: #666;
    }

    .copy-icon.copied {
      fill: #2ecc71;
    }

    .feedback-status {
      font-size: 10px;
      color: #666;
      margin-left: 4px;
      display: none;
    }

    .action-button.active .feedback-status {
      display: inline;
    }

    /* ÊâìÂ≠óÂÖâÊ†áÊïàÊûú */
    .typing-cursor {
      animation: blink 1s step-end infinite;
      color: #3498db;
    }

    @keyframes blink {
      from, to { opacity: 1; }
      50% { opacity: 0; }
    }
  </style>
</head>

<body>
  <button id="toggle-chat" class="chat-toggle-button">üí¨</button>
  <div id="chat-root"></div>

  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="trash-icon" viewBox="0 0 24 24">
      <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
    </symbol>

    <!-- ÁÇπËµûÂõæÊ†á (Á´ñËµ∑Â§ßÊãáÊåá) -->
    <symbol id="like-icon" viewBox="0 0 24 24">
      <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"/>
    </symbol>

    <!-- ÁÇπË∏©ÂõæÊ†á (ÂÄíÁΩÆÂ§ßÊãáÊåá) -->
    <symbol id="dislike-icon" viewBox="0 0 24 24">
      <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z" transform="rotate(180 12 12)"/>
    </symbol>

    <symbol id="copy-icon" viewBox="0 0 24 24">
      <path
        d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
    </symbol>
  </svg>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    const loadChatHistory = () => {
      try {
        const history = localStorage.getItem('chatHistory');
        return history ? JSON.parse(history) : [];
      } catch (e) {
        console.error('Error loading chat history:', e);
        return [];
      }
    };

    const saveChatHistory = (history) => {
      try {
        localStorage.setItem('chatHistory', JSON.stringify(history));
      } catch (e) {
        console.error('Error saving chat history:', e);
      }
    };

    const loadChatState = () => {
      try {
        const state = localStorage.getItem('chatState');
        if (state) {
          const parsedState = JSON.parse(state);
          return {
            position: parsedState.position || { x: window.innerWidth - 470, y: window.innerHeight - 520 },
            size: parsedState.size || { width: 450, height: 500 }
          };
        }
        return {
          position: { x: window.innerWidth - 470, y: window.innerHeight - 520 },
          size: { width: 450, height: 500 }
        };
      } catch (e) {
        console.error('Error loading chat state:', e);
        return {
          position: { x: window.innerWidth - 470, y: window.innerHeight - 520 },
          size: { width: 450, height: 500 }
        };
      }
    };

    const saveChatState = (state) => {
      try {
        localStorage.setItem('chatState', JSON.stringify(state));
      } catch (e) {
        console.error('Error saving chat state:', e);
      }
    };

    const loadFeedback = () => {
      try {
        const feedback = localStorage.getItem('messageFeedback');
        return feedback ? JSON.parse(feedback) : {};
      } catch (e) {
        console.error('Error loading feedback:', e);
        return {};
      }
    };

    const saveFeedback = (feedback) => {
      try {
        localStorage.setItem('messageFeedback', JSON.stringify(feedback));
      } catch (e) {
        console.error('Error saving feedback:', e);
      }
    };

    const copyToClipboard = (text) => {
      navigator.clipboard.writeText(text).then(() => {
        console.log('Text copied to clipboard');
      }).catch(err => {
        console.error('Failed to copy text: ', err);
      });
    };

    const formatTime = (timestamp) => {
      const now = Date.now();
      const diff = now - timestamp;
      const date = new Date(timestamp);

      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
      if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
      if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;
      return date.toLocaleDateString();
    };

    const fetchAIResponse = async (message) => {
      // Ê®°ÊãüAPIÂª∂Ëøü
      await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 1000));
      
      // ÈïøÂõûÂ§çÁ§∫‰æã
      const longResponses = [
        `ËøôÊòØ‰∏Ä‰∏™ËæÉÈïøÁöÑAIÂõûÂ§çÁ§∫‰æãÔºåÊºîÁ§∫ÈÄêÂ≠óËæìÂá∫ÊïàÊûú„ÄÇ\n\nÂΩìAIÂõûÂ§çÂÜÖÂÆπËæÉÈïøÊó∂ÔºåÊàë‰ª¨Â∏åÊúõÂÆÉËÉΩÈÄêÂ≠óÊòæÁ§∫ÔºåÁªôÁî®Êà∑Êõ¥Ëá™ÁÑ∂ÁöÑ‰∫§‰∫í‰ΩìÈ™å„ÄÇ\n\nËøôÁßçÊïàÊûúÁâπÂà´ÈÄÇÂêàËß£ÈáäÊÄßÂÜÖÂÆπ„ÄÅËØ¶ÁªÜËØ¥ÊòéÊàñÂ§öÊÆµËêΩÂõûÂ§ç„ÄÇ`,
        `ËÆ©Êàë‰ª¨ËØ¶ÁªÜÂàÜÊûêËøô‰∏™ÈóÆÈ¢òÔºö\n\n1. È¶ñÂÖàÔºåÈúÄË¶ÅËÄÉËôëÈóÆÈ¢òÁöÑËÉåÊôØÂíå‰∏ä‰∏ãÊñá\n2. ÁÑ∂ÂêéÔºåÂàÜÊûêÂèØËÉΩÁöÑÂΩ±ÂìçÂõ†Á¥†\n3. ÊúÄÂêéÔºåÊèêÂá∫Ëß£ÂÜ≥ÊñπÊ°àÂíåÂª∫ËÆÆ\n\nËøôÁßçÁªìÊûÑÂåñÁöÑÈïøÂõûÂ§çÂæàÈÄÇÂêàÈÄêÂ≠óÊòæÁ§∫„ÄÇ`,
        `ÊÑüË∞¢ÊÇ®ÁöÑÊèêÈóÆ„ÄÇ‰∏∫‰∫ÜÁªôÊÇ®ÊúÄÂáÜÁ°ÆÁöÑÂõûÁ≠îÔºåÊàëÈúÄË¶ÅËØ¶ÁªÜËß£ÈáäÂá†‰∏™ÂÖ≥ÈîÆÁÇπÔºö\n\n- Ê¶ÇÂøµÂÆö‰πâÔºöÈ¶ñÂÖàÊòéÁ°ÆÈóÆÈ¢òÁöÑÊ†∏ÂøÉÊ¶ÇÂøµ\n- ÂΩ±ÂìçÂõ†Á¥†ÔºöÂàÜÊûêÂΩ±ÂìçÁªìÊûúÁöÑÂ§ö‰∏™ÂèòÈáè\n- Â∫îÁî®Âú∫ÊôØÔºöËÆ®ËÆ∫Âú®ÂÆûÈôÖ‰∏≠ÁöÑÂ∫îÁî®\n- Ê≥®ÊÑè‰∫ãÈ°πÔºöÊèêÈÜíÈúÄË¶ÅÊ≥®ÊÑèÁöÑÂÖ≥ÈîÆÁÇπ\n\nËøôÊ†∑ÂàÜÊ≠•È™§ÁöÑÂõûÂ§çÊñπÂºèËÉΩËÆ©‰ø°ÊÅØÊõ¥Êòì‰∫éÁêÜËß£„ÄÇ`
      ];
      
      // Áü≠ÂõûÂ§çÁ§∫‰æã
      const shortResponses = [
        'ÊòéÁôΩ‰∫Ü„ÄÇ',
        'Â•ΩÁöÑ„ÄÇ',
        'ÊàëÁêÜËß£„ÄÇ',
        'ËØ∑ÁªßÁª≠„ÄÇ',
        'Êî∂Âà∞„ÄÇ',
        'ÂóØ„ÄÇ',
        'ÊòØÁöÑ„ÄÇ',
        '‰∏çÊòØ„ÄÇ'
      ];
      
      // Ê†πÊçÆËæìÂÖ•ÈïøÂ∫¶ÂÜ≥ÂÆöËøîÂõûÈïøÂõûÂ§çËøòÊòØÁü≠ÂõûÂ§ç
      const response = message.length > 30 
        ? longResponses[Math.floor(Math.random() * longResponses.length)]
        : shortResponses[Math.floor(Math.random() * shortResponses.length)];
      
      return {
        success: true,
        data: {
          response,
          timestamp: Date.now(),
          isLongResponse: message.length > 30 // Ê†áËÆ∞ÊòØÂê¶‰∏∫ÈïøÂõûÂ§ç
        }
      };
    };

    const FloatingChatApp = () => {
      const [isOpen, setIsOpen] = useState(false);
      const [isMaximized, setIsMaximized] = useState(false);
      const savedState = loadChatState();
      const [position, setPosition] = useState(savedState.position);
      const [size, setSize] = useState(savedState.size);
      const [chatHistory, setChatHistory] = useState(loadChatHistory());
      const [activeChatId, setActiveChatId] = useState(null);
      const [activeChat, setActiveChat] = useState(null);
      const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
      const [resizeStart, setResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 });
      const [isNewChatPrompt, setIsNewChatPrompt] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [feedback, setFeedback] = useState(loadFeedback());
      const [copiedId, setCopiedId] = useState(null);
      const [enlargedImage, setEnlargedImage] = useState(null);
      const chatWindowRef = useRef(null);
      const messagesEndRef = useRef(null);
      const messageInputRef = useRef(null);
      const messagesContainerRef = useRef(null);
      const typingTimers = useRef({});

      // Áî® useRef ËøΩË∏™ÊãñÊãΩÂíåÁº©ÊîæÁä∂ÊÄÅÔºåÂΩªÂ∫ïÁßªÈô§ useState Áõ∏ÂÖ≥ÂÜó‰Ωô
      const isDraggingRef = useRef(false);
      const isResizingRef = useRef(false);
      // ËäÇÊµÅÂáΩÊï∞ÂíåËäÇÊµÅÂêéÁöÑ setPosition/setSize
      function throttle(func, wait) {
        let lastTime = 0;
        let timeout;
        return function (...args) {
          const now = Date.now();
          if (now - lastTime >= wait) {
            lastTime = now;
            func.apply(this, args);
          } else {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
              lastTime = Date.now();
              func.apply(this, args);
            }, wait - (now - lastTime));
          }
        };
      }
      const throttledSetPosition = useRef(throttle(setPosition, 16));
      const throttledSetSize = useRef(throttle(setSize, 16));

      const scrollToBottom = useCallback(() => {
        if (messagesContainerRef.current) {
          messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
        }
      }, []);

      const startNewChatPrompt = useCallback(() => {
        setIsNewChatPrompt(true);
        setActiveChatId(null);
        setActiveChat(null);
        setTimeout(() => {
          if (messageInputRef.current) {
            messageInputRef.current.focus();
          }
        }, 0);
      }, []);

      const handleFeedback = useCallback((messageId, type) => {
        setFeedback(prev => {
          const newFeedback = { ...prev };

          if (newFeedback[messageId]) {
            if (newFeedback[messageId].type === type) {
              delete newFeedback[messageId];
            } else {
              newFeedback[messageId] = { type, timestamp: Date.now() };
            }
          } else {
            newFeedback[messageId] = { type, timestamp: Date.now() };
          }

          saveFeedback(newFeedback);
          return newFeedback;
        });
      }, []);

      const handleCopy = useCallback((messageId, text) => {
        copyToClipboard(text);
        setCopiedId(messageId);
        setTimeout(() => setCopiedId(null), 2000);
      }, []);

      const createNewChat = useCallback(async (firstMessage) => {
        if (!firstMessage.trim()) return;

        const newChatId = generateId();
        const chatTitle = firstMessage.length > 20
          ? firstMessage.substring(0, 20) + '...'
          : firstMessage;

        const newUserMessage = {
          id: generateId(),
          text: firstMessage,
          sender: 'user',
          timestamp: Date.now()
        };

        const newChat = {
          id: newChatId,
          title: chatTitle,
          messages: [newUserMessage],
          timestamp: Date.now(),
          isNew: false
        };

        setActiveChatId(newChatId);
        setActiveChat(newChat);
        setIsNewChatPrompt(false);

        setChatHistory(prev => {
          const newHistory = [newChat, ...prev];
          saveChatHistory(newHistory);
          return newHistory;
        });

        setIsLoading(true);
        try {
          const response = await fetchAIResponse(firstMessage);
          if (response.success) {
            const newBotMessage = {
              id: generateId(),
              text: '', // ÂàùÂßã‰∏∫Á©∫
              fullText: response.data.response, // ‰øùÂ≠òÂÆåÊï¥ÊñáÊú¨
              sender: 'bot',
              timestamp: response.data.timestamp,
              isTyping: response.data.isLongResponse // ÊòØÂê¶ÈúÄË¶ÅÈÄêÂ≠óÊòæÁ§∫
            };

            setActiveChat(prev => ({
              ...prev,
              messages: [...prev.messages, newBotMessage]
            }));

            // Â¶ÇÊûúÊòØÈïøÂõûÂ§çÔºåÂêØÂä®ÈÄêÂ≠óÊòæÁ§∫ÊïàÊûú
            if (response.data.isLongResponse) {
              let displayedText = '';
              const fullText = response.data.response;
              const messageId = newBotMessage.id;
              
              typingTimers.current[messageId] = setInterval(() => {
                if (displayedText.length < fullText.length) {
                  displayedText = fullText.substring(0, displayedText.length + 1);
                  setActiveChat(prev => {
                    const updatedMessages = [...prev.messages];
                    const lastMessage = updatedMessages[updatedMessages.length - 1];
                    if (lastMessage.sender === 'bot') {
                      lastMessage.text = displayedText;
                    }
                    return { ...prev, messages: updatedMessages };
                  });
                  scrollToBottom();
                } else {
                  clearInterval(typingTimers.current[messageId]);
                  delete typingTimers.current[messageId];
                  setActiveChat(prev => {
                    const updatedMessages = [...prev.messages];
                    const lastMessage = updatedMessages[updatedMessages.length - 1];
                    if (lastMessage.sender === 'bot') {
                      lastMessage.isTyping = false;
                    }
                    return { ...prev, messages: updatedMessages };
                  });
                }
              }, 30); // ÊØè30ÊØ´ÁßíÊòæÁ§∫‰∏Ä‰∏™Â≠ó
            } else {
              // Áü≠ÂõûÂ§çÁõ¥Êé•ÊòæÁ§∫
              setActiveChat(prev => {
                const updatedMessages = [...prev.messages];
                const lastMessage = updatedMessages[updatedMessages.length - 1];
                if (lastMessage.sender === 'bot') {
                  lastMessage.text = response.data.response;
                }
                return { ...prev, messages: updatedMessages };
              });
            }

            // Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩï
            setChatHistory(prev => {
              const updatedHistory = [...prev];
              const chatIndex = updatedHistory.findIndex(chat => chat.id === newChatId);
              if (chatIndex !== -1) {
                updatedHistory[chatIndex] = {
                  ...updatedHistory[chatIndex],
                  messages: [...updatedHistory[chatIndex].messages, {
                    ...newBotMessage,
                    text: response.data.response // ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠‰øùÂ≠òÂÆåÊï¥ÊñáÊú¨
                  }]
                };
                saveChatHistory(updatedHistory);
              }
              return updatedHistory;
            });
          }
        } catch (error) {
          console.error('Error fetching AI response:', error);
        } finally {
          setIsLoading(false);
          setTimeout(() => {
            scrollToBottom();
            // ÊÅ¢Â§çËæìÂÖ•Ê°ÜÁÑ¶ÁÇπ
            if (messageInputRef.current) {
              messageInputRef.current.focus();
            }
          }, 100);
        }
      }, [scrollToBottom]);

      const loadChat = useCallback((chatId) => {
        const chatFromHistory = chatHistory.find(chat => chat.id === chatId);
        if (chatFromHistory) {
          setActiveChatId(chatId);
          setActiveChat({
            ...chatFromHistory,
            isNew: false
          });
          setIsNewChatPrompt(false);
          setTimeout(() => {
            scrollToBottom();
            if (messageInputRef.current) {
              messageInputRef.current.focus();
            }
          }, 100);
        }
      }, [chatHistory, scrollToBottom]);

      const deleteChat = useCallback((chatId, e) => {
        e.stopPropagation();

        if (activeChatId === chatId) {
          setActiveChatId(null);
          setActiveChat(null);
        }

        setChatHistory(prev => {
          const newHistory = prev.filter(chat => chat.id !== chatId);
          saveChatHistory(newHistory);
          return newHistory;
        });
      }, [activeChatId]);

      const sendMessage = useCallback(async (text) => {
        if (!text.trim()) return;

        if (isNewChatPrompt) {
          await createNewChat(text);
          return;
        }

        const newUserMessage = {
          id: generateId(),
          text: text,
          sender: 'user',
          timestamp: Date.now()
        };

        const updatedMessages = [...(activeChat?.messages || []), newUserMessage];
        const updatedChat = {
          ...(activeChat || { id: generateId(), title: 'New Chat', isNew: false }),
          messages: updatedMessages,
          isNew: false
        };

        setActiveChat(updatedChat);
        if (!activeChatId) setActiveChatId(updatedChat.id);

        setChatHistory(prev => {
          const existingIndex = prev.findIndex(chat => chat.id === updatedChat.id);
          const newHistory = existingIndex >= 0
            ? [...prev.slice(0, existingIndex), updatedChat, ...prev.slice(existingIndex + 1)]
            : [updatedChat, ...prev];

          saveChatHistory(newHistory);
          return newHistory;
        });

        setIsLoading(true);
        try {
          const response = await fetchAIResponse(text);
          if (response.success) {
            const newBotMessage = {
              id: generateId(),
              text: '', // ÂàùÂßã‰∏∫Á©∫
              fullText: response.data.response, // ‰øùÂ≠òÂÆåÊï¥ÊñáÊú¨
              sender: 'bot',
              timestamp: response.data.timestamp,
              isTyping: response.data.isLongResponse // ÊòØÂê¶ÈúÄË¶ÅÈÄêÂ≠óÊòæÁ§∫
            };

            setActiveChat(prev => ({
              ...prev,
              messages: [...prev.messages, newBotMessage]
            }));

            // Â¶ÇÊûúÊòØÈïøÂõûÂ§çÔºåÂêØÂä®ÈÄêÂ≠óÊòæÁ§∫ÊïàÊûú
            if (response.data.isLongResponse) {
              let displayedText = '';
              const fullText = response.data.response;
              const messageId = newBotMessage.id;
              
              typingTimers.current[messageId] = setInterval(() => {
                if (displayedText.length < fullText.length) {
                  displayedText = fullText.substring(0, displayedText.length + 1);
                  setActiveChat(prev => {
                    const updatedMessages = [...prev.messages];
                    const lastMessage = updatedMessages[updatedMessages.length - 1];
                    if (lastMessage.sender === 'bot') {
                      lastMessage.text = displayedText;
                    }
                    return { ...prev, messages: updatedMessages };
                  });
                  scrollToBottom();
                } else {
                  clearInterval(typingTimers.current[messageId]);
                  delete typingTimers.current[messageId];
                  setActiveChat(prev => {
                    const updatedMessages = [...prev.messages];
                    const lastMessage = updatedMessages[updatedMessages.length - 1];
                    if (lastMessage.sender === 'bot') {
                      lastMessage.isTyping = false;
                    }
                    return { ...prev, messages: updatedMessages };
                  });
                }
              }, 30); // ÊØè30ÊØ´ÁßíÊòæÁ§∫‰∏Ä‰∏™Â≠ó
            } else {
              // Áü≠ÂõûÂ§çÁõ¥Êé•ÊòæÁ§∫
              setActiveChat(prev => {
                const updatedMessages = [...prev.messages];
                const lastMessage = updatedMessages[updatedMessages.length - 1];
                if (lastMessage.sender === 'bot') {
                  lastMessage.text = response.data.response;
                }
                return { ...prev, messages: updatedMessages };
              });
            }

            // Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩï
            setChatHistory(prev => {
              const updatedHistory = [...prev];
              const chatIndex = updatedHistory.findIndex(chat => chat.id === updatedChat.id);
              if (chatIndex !== -1) {
                updatedHistory[chatIndex] = {
                  ...updatedHistory[chatIndex],
                  messages: [...updatedHistory[chatIndex].messages, {
                    ...newBotMessage,
                    text: response.data.response // ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠‰øùÂ≠òÂÆåÊï¥ÊñáÊú¨
                  }]
                };
                saveChatHistory(updatedHistory);
              }
              return updatedHistory;
            });
          }
        } catch (error) {
          console.error('Error fetching AI response:', error);
        } finally {
          setIsLoading(false);
          setTimeout(() => {
            scrollToBottom();
            // ÊÅ¢Â§çËæìÂÖ•Ê°ÜÁÑ¶ÁÇπ
            if (messageInputRef.current) {
              messageInputRef.current.focus();
            }
          }, 100);
        }
      }, [isNewChatPrompt, createNewChat, activeChat, activeChatId, scrollToBottom]);

      const handleSendMessage = useCallback(() => {
        const input = messageInputRef.current;
        const message = input.value.trim();

        if (message) {
          sendMessage(message);
          input.value = '';
        }
      }, [sendMessage]);

      const handleKeyPress = useCallback((e) => {
        if (e.key === 'Enter') {
          handleSendMessage();
        }
      }, [handleSendMessage]);

      const handleDragStart = useCallback((e) => {
        if (e.target.className.includes('draggable-header')) {
          isDraggingRef.current = true;
          setDragStart({
            x: e.clientX - position.x,
            y: e.clientY - position.y
          });
          e.preventDefault();
        }
      }, [position.x, position.y]);

      const handleDrag = useCallback((e) => {
        if (isDraggingRef.current) {
          const newX = e.clientX - dragStart.x;
          const newY = e.clientY - dragStart.y;
          const boundedX = Math.max(0, Math.min(window.innerWidth - size.width, newX));
          const boundedY = Math.max(0, Math.min(window.innerHeight - size.height, newY));
          throttledSetPosition.current({ x: boundedX, y: boundedY });
        }
      }, [dragStart.x, dragStart.y, size.width, size.height]);

      const handleDragEnd = useCallback(() => {
        if (!isDraggingRef.current) return;
        isDraggingRef.current = false;
        saveChatState({ position, size });
      }, [position, size]);

      const handleResizeStart = (e) => {
        console.log('resize start', e);
        isResizingRef.current = true;
        setResizeStart({
          x: e.clientX,
          y: e.clientY,
          width: size.width,
          height: size.height
        });
        e.preventDefault();
      };

      const handleResize = useCallback((e) => {
        if (isResizingRef.current) {
          const deltaX = e.clientX - resizeStart.x;
          const deltaY = e.clientY - resizeStart.y;
          const newWidth = Math.max(300, resizeStart.width + deltaX);
          const newHeight = Math.max(400, resizeStart.height + deltaY);
          throttledSetSize.current({ width: newWidth, height: newHeight });
        }
      }, [resizeStart.x, resizeStart.y, resizeStart.width, resizeStart.height]);

      const handleResizeEnd = useCallback((e) => {
        if (!isResizingRef.current) return;
        isResizingRef.current = false;
        if (e && typeof e.clientX === 'number' && typeof e.clientY === 'number') {
          const deltaX = e.clientX - resizeStart.x;
          const deltaY = e.clientY - resizeStart.y;
          const newWidth = Math.max(300, resizeStart.width + deltaX);
          const newHeight = Math.max(400, resizeStart.height + deltaY);
          const newSize = { width: newWidth, height: newHeight };
          setSize(newSize);
          saveChatState({ position, size: newSize });
          console.log('ResizeEnd:', newSize);
        } else {
          console.log('ResizeEnd: event missing or invalid', e);
        }
      }, [position, resizeStart]);

      useEffect(() => {
        // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÈô§ÊâÄÊúâÂÆöÊó∂Âô®
        return () => {
          const timers = Object.values(typingTimers.current);
          timers.forEach(timer => clearInterval(timer));
        };
      }, []);

      useEffect(() => {
        const handleMouseMove = (e) => {
          if (isMaximized) return;
          if (isDraggingRef.current) handleDrag(e);
          if (isResizingRef.current) handleResize(e);
        };

        const handleMouseUp = (e) => {
          if (isMaximized) return;
          if (isDraggingRef.current) handleDragEnd();
          handleResizeEnd(e); // handleResizeEnd ÂÜÖÈÉ®‰ºöÂà§Êñ≠ isResizingRef
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        const toggleButton = document.getElementById('toggle-chat');
        if (toggleButton) {
          const handleToggleClick = () => {
            const newIsOpen = !isOpen;
            setIsOpen(newIsOpen);
            if (newIsOpen && !activeChatId && !isNewChatPrompt) {
              if (chatHistory.length > 0) {
                loadChat(chatHistory[0].id);
              } else {
                startNewChatPrompt();
              }
            }

            if (!newIsOpen) {
              saveChatState({
                position,
                size
              });
            }
          };

          toggleButton.addEventListener('click', handleToggleClick);

          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            toggleButton.removeEventListener('click', handleToggleClick);
          };
        }
      }, [isOpen, activeChatId, isNewChatPrompt,
        handleDrag, handleResize, handleDragEnd, handleResizeEnd,
        startNewChatPrompt, position, size, chatHistory, loadChat]);

      useEffect(() => {
        const handleResizeWindow = () => {
          if (!isMaximized) {
            setPosition({
              x: Math.min(position.x, window.innerWidth - size.width),
              y: Math.min(position.y, window.innerHeight - size.height)
            });
          }
        };

        window.addEventListener('resize', handleResizeWindow);
        return () => window.removeEventListener('resize', handleResizeWindow);
      }, [isMaximized, position, size]);

      useEffect(() => {
        if (isOpen && activeChat?.messages?.length > 0) {
          scrollToBottom();
        }
      }, [isOpen, activeChat?.messages, scrollToBottom]);

      const renderMessage = (message) => (
        <div key={message.id} className={`message ${message.sender}`}>
          <div className="message-bubble">
            {/* Êñá‰ª∂ÊàñÂõæÁâáÊ∂àÊÅØ‰ºòÂÖàÊòæÁ§∫ */}
            {message.isImage && message.fileUrl ? (
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
                <img
                  src={message.fileUrl}
                  alt={message.fileName}
                  style={{ maxWidth: 180, maxHeight: 120, borderRadius: 6, marginBottom: 4, cursor: 'pointer', border: '1px solid #eee' }}
                  onClick={() => setEnlargedImage({ url: message.fileUrl, name: message.fileName })}
                />
                <div style={{ fontSize: 12, color: 'white', wordBreak: 'break-all' }}>{message.fileName}</div>
              </div>
            ) : message.fileUrl ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                {/* Êú¨Âú∞SVGÊñá‰ª∂ÂõæÊ†á */}
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ marginRight: 4, verticalAlign: 'middle' }}>
                  <rect x="3" y="3" width="18" height="18" rx="2" fill="#e9ecef" stroke="#b0b0b0" strokeWidth="1.2"/>
                  <path d="M7 7H17V9H7V7ZM7 11H17V13H7V11ZM7 15H13V17H7V15Z" fill="#3498db"/>
                </svg>
                <a href={message.fileUrl} download={message.fileName} style={{ color: 'white', textDecoration: 'underline', wordBreak: 'break-all', fontSize: 13 }}>{message.fileName}</a>
              </div>
            ) : null}
            {/* ÊôÆÈÄöÊñáÊú¨Ê∂àÊÅØ */}
            {message.text}
            {message.isTyping && <span className="typing-cursor">|</span>}
          </div>
          <div className="message-time">
            <span className="message-sender">
              {message.sender === 'user' ? 'You' : 'Assistant'} ¬∑ {formatTime(message.timestamp)}
            </span>

            {message.sender === 'bot' && (
              <div className="message-actions">
                <button
                  className={`action-button ${feedback[message.id]?.type === 'like' ? 'active' : ''}`}
                  onClick={() => handleFeedback(message.id, 'like')}
                  title="Like this message"
                >
                  <svg className={`icon like-icon ${feedback[message.id]?.type === 'like' ? 'liked' : ''}`}>
                    <use xlinkHref="#like-icon" />
                  </svg>
                  {feedback[message.id]?.type === 'like' && (
                    <span className="feedback-status">Liked</span>
                  )}
                </button>

                <button
                  className={`action-button ${feedback[message.id]?.type === 'dislike' ? 'active' : ''}`}
                  onClick={() => handleFeedback(message.id, 'dislike')}
                  title="Dislike this message"
                >
                  <svg className={`icon dislike-icon ${feedback[message.id]?.type === 'dislike' ? 'disliked' : ''}`}>
                    <use xlinkHref="#dislike-icon" />
                  </svg>
                  {feedback[message.id]?.type === 'dislike' && (
                    <span className="feedback-status">Disliked</span>
                  )}
                </button>

                <button
                  className={`action-button ${copiedId === message.id ? 'active' : ''}`}
                  onClick={() => handleCopy(message.id, message.text)}
                  title="Copy to clipboard"
                >
                  <svg className={`icon copy-icon ${copiedId === message.id ? 'copied' : ''}`}>
                    <use xlinkHref="#copy-icon" />
                  </svg>
                  {copiedId === message.id && (
                    <span className="feedback-status">Copied!</span>
                  )}
                </button>
              </div>
            )}
          </div>
        </div>
      );

      if (!isOpen) return null;

      return (
        <div
          ref={chatWindowRef}
          className={`chat-window ${isMaximized ? 'maximized' : ''}`}
          style={{
            left: isMaximized ? '20px' : `${position.x}px`,
            top: isMaximized ? '20px' : `${position.y}px`,
            width: isMaximized ? 'calc(100vw - 40px)' : `${size.width}px`,
            height: isMaximized ? 'calc(100vh - 40px)' : `${size.height}px`,
          }}
        >
          <div
            className="draggable-header chat-header"
            onMouseDown={handleDragStart}
          >
            <div className="chat-title">AI Chat Assistant</div>
            <div className="chat-controls">
              <button onClick={() => setIsMaximized(!isMaximized)}>
                {isMaximized ? 'üóó' : 'üóñ'}
              </button>
              <button onClick={() => setIsOpen(false)}>√ó</button>
            </div>
          </div>

          <div className="sidebar">
            <button
              className="new-chat-btn"
              onClick={startNewChatPrompt}
              title="Start a new conversation"
            >
              + New Chat
            </button>

            {chatHistory.map(chat => (
              <div
                key={chat.id}
                className={`history-item ${activeChatId === chat.id ? 'active' : ''}`}
                onClick={() => loadChat(chat.id)}
                title={`${chat.title}\n${formatTime(chat.timestamp)}`}
              >
                <div className="history-item-content">
                  {chat.title}
                  <div className="time">{formatTime(chat.timestamp)}</div>
                </div>
                <button
                  className="delete-chat-btn"
                  onClick={(e) => deleteChat(chat.id, e)}
                  title="Delete this chat"
                >
                  <svg className="trash-icon">
                    <use xlinkHref="#trash-icon" />
                  </svg>
                </button>
              </div>
            ))}
          </div>

          <div className="chat-content">
            {isNewChatPrompt ? (
              <div className="new-chat-prompt">
                <h3>Start a New Chat</h3>
                <p>Type your first message to begin a new conversation</p>
                <div className="input-area">
                  <input
                    ref={messageInputRef}
                    type="text"
                    className="message-input"
                    placeholder="Type your first message..."
                    onKeyPress={handleKeyPress}
                  />
                  <button
                    className="send-button"
                    onClick={handleSendMessage}
                    disabled={isLoading}
                  >
                    {isLoading ? '...' : 'Start Chat'}
                  </button>
                </div>
              </div>
            ) : activeChat ? (
              <>
                <div className="messages-container" ref={messagesContainerRef}>
                  {activeChat.messages.map(renderMessage)}
                  <div ref={messagesEndRef} />
                </div>

                <div className="input-area">
                  <input
                    ref={messageInputRef}
                    type="text"
                    className="message-input"
                    placeholder="Type a message..."
                    onKeyPress={handleKeyPress}
                    disabled={isLoading}
                  />
                  <input
                    type="file"
                    id="file-upload"
                    style={{ display: 'none' }}
                    multiple
                    accept="image/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,.txt"
                    onChange={e => {
                      const files = Array.from(e.target.files);
                      if (!files.length) return;
                      files.forEach(file => {
                        const reader = new FileReader();
                        if (file.type.startsWith('image/')) {
                          reader.onload = (event) => {
                            const content = event.target.result;
                            const fileMessage = {
                              id: generateId(),
                              text: '',
                              sender: 'user',
                              timestamp: Date.now(),
                              fileName: file.name,
                              fileType: file.type,
                              fileUrl: content,
                              isImage: true
                            };
                            setActiveChat(prev => {
                              if (!prev) return prev;
                              const updatedMessages = [...prev.messages, fileMessage];
                              return { ...prev, messages: updatedMessages };
                            });
                          };
                          reader.readAsDataURL(file);
                        } else {
                          reader.onload = (event) => {
                            const blob = new Blob([event.target.result], { type: file.type });
                            const url = URL.createObjectURL(blob);
                            const fileMessage = {
                              id: generateId(),
                              text: '',
                              sender: 'user',
                              timestamp: Date.now(),
                              fileName: file.name,
                              fileType: file.type,
                              fileUrl: url,
                              isImage: false
                            };
                            setActiveChat(prev => {
                              if (!prev) return prev;
                              const updatedMessages = [...prev.messages, fileMessage];
                              return { ...prev, messages: updatedMessages };
                            });
                          };
                          reader.readAsArrayBuffer(file);
                        }
                      });
                      // Ê∏ÖÁ©∫ input ‰ª•‰æøËøûÁª≠‰∏ä‰º†Âêå‰∏ÄÊñá‰ª∂
                      e.target.value = '';
                    }}
                  />
                  <button
                    className="send-button"
                    onClick={handleSendMessage}
                    disabled={isLoading}
                  >
                    {isLoading ? '...' : 'Send'}
                  </button>
                  <button
                    className="send-button"
                    style={{ marginLeft: 8 }}
                    onClick={() => document.getElementById('file-upload').click()}
                    title="‰∏ä‰º†Êñá‰ª∂ÊàñÂõæÁâá"
                  >
                    üìé
                  </button>
                </div>
              </>
            ) : (
              <div className="new-chat-prompt">
                <h3>Welcome to AI Chat Assistant</h3>
                <p>Click "New Chat" to start a conversation</p>
              </div>
            )}
          </div>

          {!isMaximized && (
            <div
              className="resize-handle"
              onMouseDown={handleResizeStart}
            ></div>
          )}

          {/* ÊîæÂ§ßÂõæÁâáÈÅÆÁΩ©Â±Ç */}
          {enlargedImage && (
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                width: '100vw',
                height: '100vh',
                background: 'rgba(0,0,0,0.7)',
                zIndex: 2000,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
              onClick={() => setEnlargedImage(null)}
            >
              <img
                src={enlargedImage.url}
                alt={enlargedImage.name}
                style={{
                  maxWidth: '90vw',
                  maxHeight: '90vh',
                  borderRadius: 8,
                  boxShadow: '0 4px 24px rgba(0,0,0,0.5)',
                  background: '#fff',
                }}
                onClick={e => e.stopPropagation()}
              />
              <button
                style={{
                  position: 'fixed',
                  top: 32,
                  right: 48,
                  fontSize: 32,
                  color: '#fff',
                  background: 'none',
                  border: 'none',
                  cursor: 'pointer',
                  zIndex: 2100,
                }}
                onClick={() => setEnlargedImage(null)}
                title="ÂÖ≥Èó≠"
              >√ó</button>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<FloatingChatApp />, document.getElementById('chat-root'));
  </script>
</body>

</html>
